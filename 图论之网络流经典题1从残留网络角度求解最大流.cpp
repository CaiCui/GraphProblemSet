#pragma comment(linker,"/STACK:1024000000,1024000000")
#include<bits/stdc++.h>
using namespace std;
/*
  图论之网络最大流
  POJ1149 迈克卖猪问题 hard problem!
  1.如何正确构造出容量网络是解决本题的关键,这是难点一，需要做大量题找出建模的感觉。

  2.网络建立好后使用增广路标号法求解即可。

  本题书上的解法统一了正反邻接边，比较巧妙。可以从残留网络角度考虑，
  书上残留网络部分定义了残留容量，一个是c'=c-f表示每条弧可以增加的流量，为正数，
  还有一个定义是：c'=-f，表示从u到v流量减少了f，等效于从v到u流量增加，称为反向的残留容量，所以在绘制
  残留网络时，不仅要绘制出c'=c-f的边，还要绘制出反向的边，即c'=-f,这样才能构造出残留网络。

  所以本题不同于之前的第一道求解最大流的题，那道是严格按照书上p256页的算法从容量网络角度给出的解答，
  比较清晰也好理解，但是代码较多。本题最大流的求解则是从实际流量角度和残留网络角度给出的。
  首先：
   if(prev[i]==-2&&(p=customer[v][i]-flow[v][i]))
                {
                    prev[i]=v;
                    Queue[qe]=i;
                    qe++;
                    minflow[i]=(minflow[v]<p)?minflow[v]:p;
                }
   这部分代码在判断时只考虑了该点是否被标记，而没有将v->i和i->v做弧的正向与反向区分，
   原因是它用了减法来判断，因为customer[][]和flow[][]初始化时全都赋值为0，只有点与点间有有向边时，
   customer[][]才会有值表示容量，否则都为0表示容量为0，所以当p不为0时，才会进行增广操作，什么时候p不为0呢？
   首先customer[v][i]-flow[v][i]>0，即有容量可以扩展，那么我们就增广，这对应了增广方向和弧方向一致的时候，即“正向”，
   还有一种就是“反向”，所以这就是巧妙的地方。由于反向的时候，v->i之间没有有向边，即customer[v][i]==0,所以本题的标号法是从实际流量角度来解答的，
   虽然customer[v][i]==0但是v和i之间可能存在反向流量，即反向的残留容量，所以我们在更新时,就是下面的代码：
   for(i=prev[t],j=t;i!=-1;j=i,i=prev[i])
        {
            flow[i][j]=flow[i][j]+minflow[t];
            flow[j][i]=-flow[i][j];
        }
    对于正向流量要增加，而反向残留容量直接就赋予为负的正向流量，表示我有能力流回去，为什么会这样呢，因为网络中会存在同层的节点情形，如下图：
        v2--v4
      / |     \
    v1  |      v6
      \ |     /
        v3--v5
     v2,v3就是同层，假如有增广路v1-v2-v3-v4-v6,即v2->v3有有向边，而v3->v2无，那么也可能会出现v1-v3-v2-v4-v6的增广路，即网络流中的有向图即使无有向边也可以走通，
     因为走的是流，而不是边，边的方向只是表示点与点间的关系，便于解释。所以每一条弧都有可能成为另一条增广路的反向路径，因此，我们才从弧的角度进行增广，不光要更新那些
     有有向边的可以增加流量的正向弧，还有把每一个更新的正向弧的反向残留容量求出，这样是为了防止该正向弧在成为某一条增广路的反向弧计算时的需要，通过这样的更新算法，
     就可以不用考虑边的正反而统一使用一个减法customer[v][i]-flow[v][i]来求解网络流了，这就是第二种可以扩展增广路的情形，即customer[v][i]=0，但是flow[v][i]的绝对值>0，
     此时对应于原来算法的反向弧情形，恰好0-负数=正数，这样就完成了增广路中反向弧的流量的求解，从而达到了和之前那个最一般的算法一样的效果，这种方法统一了正反弧，很巧妙！！！！
     
     归根结底一句话总结：
     就是把所有边全部视为“正向”的弧，只考虑正向弧加法更新，不考虑反弧，因为反弧也可以看做负的正向弧。比较绕口，需要自己体会。。。就是A->B为2，对于B来说，A->B是个反弧，但是可以看做B->A，值为-2，即从B流到A -2的流，
     这样就把正反统一了。。更新时就只需要+，不需要-了，因为可能你的在做加法的flow[][]恰好是负数，所以B->A的负值的加法，就相当于之前的算法负弧A->B的正值的减法，其实和之前的算法是一样的。只是代码实现角度不一样。
     即 flow[i][j]=flow[i][j]+minflow[t];即当flow[i][j]>0时，为正弧，它包含了正弧加的更新，同时，当flow[][]<0时，表示此时为该增广路的一条负弧，所以负弧+正数，相当于减小流量值！！！即原来的反向弧的减法。一式两用，
     极其巧妙！！！！！！！！！！！！而flow[j][i]=-flow[i][j];则是为了上述这种计算而写的，每次都要求出[i][j]的反向残留容量，以便负弧出现时的更新。
     
     这其实也有一种动态规划的相似思想在里面！ 体现了一种数学上正负可统一的思想，又是一种数学之美！！！！！！！！！！！！
     好题！！！！！！！！！！！！！！！！！！！！
*/
#define INF 30000000
#define MAXM 1000 //猪圈数
#define MAXN 100  //顾客数量
int s,t;//源点，汇点，人为增加
int customer[MAXN+2][MAXN+2];//顾客容量网络，+2表示源点和汇点
int flow[MAXN+2][MAXN+2];//实际流量
int i,j;
void init()//初始化，构造容量网络
{
    int M,N;
    int num;
    int k;
    int house[MAXM];//每个猪圈初始猪数目
    int last[MAXM];//存储每个猪圈的前一个顾客的序号
    memset(last,0,sizeof(last));
    memset(customer,0,sizeof(customer));

    scanf("%d%d",&M,&N);
    //源点，汇点标号确定
    s=0;
    t=N+1;
    for(i=1;i<=M;i++)//猪圈数目初始化
        scanf("%d",&house[i]);
    for(i=1;i<=N;i++)//顾客需求读入，构造容量网络
    {
        scanf("%d",&num);
        for(j=0;j<num;j++)
        {
            scanf("%d",&k);//读入钥匙的序号
            if(last[k]==0)//第i个顾客是第k个猪圈的第一个顾客
              customer[s][i]+=house[k];
            else
              customer[last[k]][i]=INF;
            last[k]=i;
        }
        scanf("%d",&customer[i][t]);//顾客到汇点的边，权值为顾客的需求
    }
}
void ford()//求解网络流
{
    int prev[MAXN+2];//标号法标号的第一个分量
    int minflow[MAXN+2];//标号法标号的第二个分量，即可改进量
    int Queue[MAXN+2]; //BFS队列
    int qs,qe;
    int v;
    int p;
    for(i=0;i<MAXN+2;i++)//构造零流
        for(j=0;j<MAXN+2;j++)
         flow[i][j]=0;
    minflow[0]=INF;//源点处理
    while(1)//标号法
    {
        for(i=0;i<MAXN+2;i++)
            prev[i]=-2;//每一轮重新清空标号
        prev[0]=-1;//源点
        qs=0;
        Queue[qs]=0;
        qe=1;
        while(qs<qe && prev[t]==-2)
        {
            v=Queue[qs];
            qs++;
            for(i=0;i<t+1;i++)
            {
                if(prev[i]==-2&&(p=customer[v][i]-flow[v][i]))
                {
                    prev[i]=v;
                    Queue[qe]=i;
                    qe++;
                    minflow[i]=(minflow[v]<p)?minflow[v]:p;
                }
            }
        }
        if(prev[t]==-2)
            break;//end
        for(i=prev[t],j=t;i!=-1;j=i,i=prev[i])
        {
            flow[i][j]=flow[i][j]+minflow[t];
            flow[j][i]=-flow[i][j];
        }
    }
    p=0;
    for(i=0;i<t;i++)
        p+=flow[i][t];
    printf("%d\n",p);
}
int main()
{
    init();
    ford();
    return 0;
}
